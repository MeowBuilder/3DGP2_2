# 3DGP-2 Project Summary

## Project Overview
- **Project Name:** 3DGP-2
- **Objective:** To complete the 2nd assignment for 3D Graphics Programming.
- **Current Status:** Initial setup phase.

## Future Plans
- Analyze and understand the existing project structure.
- Analyze requirements and establish a feature implementation plan.
- Implement and test features in stages.
- Refactor and optimize code.

## CGameFramework Analysis
The `CGameFramework` class serves as the core of the DirectX 12 based 3D application. It manages the entire lifecycle of the application, from initialization to rendering and termination.

### Key Responsibilities:
- **DirectX 12 Initialization:** Handles the creation of the D3D12 device, command queues, command lists, swap chain, RTV/DSV descriptor heaps, and depth/stencil buffers.
- **Game Object Management:** Creates and manages `CScene` and `CPlayer` objects, including their initialization (`BuildObjects`) and release (`ReleaseObjects`).
- **Game Loop Management:** Orchestrates the main game loop, which includes:
    - **Input Processing (`ProcessInput`):
    - **Object Animation (`AnimateObjects`):** Updates the state of scene objects and the player over time.
    - **Frame Advancement (`FrameAdvance`):** The main rendering loop that prepares commands, clears render targets, renders the scene and player, presents the frame, and synchronizes with the GPU.
- **GPU Synchronization:** Utilizes fences (`WaitForGpuComplete`, `MoveToNextFrame`) to ensure proper synchronization between the CPU and GPU.
- **Window Message Handling:** Processes Windows messages for mouse, keyboard, and window activation events.
- **Resource Management:** Manages the creation and release of all DirectX 12 resources.
- **CGameFramework Player Double Free Fix:** Resolved a heap corruption error (`0xC0000374`) occurring during program termination in `CGameFramework::ReleaseObjects()`. The `delete m_pPlayer;` line was removed. Since `CPlayer` (which inherits from `CGameObject`) uses reference counting, `m_pPlayer->Release()` is sufficient to deallocate the object when its reference count drops to zero, making the subsequent `delete m_pPlayer;` a double-free.
- **CGameFramework Camera Double Free Fix:** Resolved a heap corruption error (`0xC0000374`) occurring during program termination in `CGameFramework::ReleaseObjects()`. The `delete m_pCamera;` line was removed. In `CGameFramework::BuildGameScene()`, `m_pCamera` is assigned the camera owned by `m_pPlayer` (`m_pCamera = m_pPlayer->GetCamera();`). Therefore, `m_pPlayer` is responsible for the lifetime of this camera object, and `CGameFramework` should not attempt to delete it, preventing a double-free.
- **CGameFramework Frame Rate Display in Menu Scene:** Modified `CGameFramework::FrameAdvance()` to display the frame rate in the window title (`SetWindowText`) even when the game has not started (i.e., in the menu scene). When `m_bGameStarted` is `false`, only the frame rate is shown. When `m_bGameStarted` is `true`, both the frame rate and the player's position are displayed, as before.

### Core Components Integrated:
- `CGameTimer`: For managing game time and calculating frame rates.
- `CScene`: Manages the overall game world, including objects within it.
- `CPlayer`: Represents the player character and its interactions, including camera control.
- `CCamera`: Manages the view and projection matrices for rendering.

### Workflow Summary:
1.  **Initialization (`OnCreate`):** Sets up DirectX 12, creates essential resources, and builds initial game objects.
2.  **Game Loop (`FrameAdvance`):**
    *   Updates game timer.
    *   Processes user input.
    *   Animate game objects.
    *   Records rendering commands (resource barriers, clear RTV/DSV, set render targets, render scene/player).
    *   Executes command list.
    *   Synchronizes with GPU.
    *   Presents the rendered frame.
    *   Updates frame rate and player position in window title.
3.  **Termination (`OnDestroy`):** Releases all allocated game objects and DirectX 12 resources.

## CScene Analysis
The `CScene` class is responsible for managing the game world, including its objects, lighting, and rendering pipeline configurations. It acts as a central hub for scene-specific data and operations.

### Key Responsibilities:
- **Scene Object Management:** Manages a collection of `CGameObject`s, `CShader`s, `CSkyBox`, and `CHeightMapTerrain` objects. It handles their creation (`BuildObjects`), animation (`AnimateObjects`), rendering (`Render`), and release (`ReleaseObjects`).
- **Lighting System:** Defines and manages multiple `LIGHT` sources (Point, Spot, Directional) and global ambient light. It updates light information to the GPU via a constant buffer.
- **DirectX 12 Resource Management (Scene-specific):**
    - **Root Signature:** Creates and manages the graphics root signature (`m_pd3dGraphicsRootSignature`), which defines how shaders access resources (constant buffers, textures). It includes descriptor ranges for various textures (Albedo, Normal, Specular, SkyBox, Terrain, etc.) and root parameters for camera, game object data, and lights.
    - **Descriptor Heaps (CBV/SRV):** Utilizes a static `CDescriptorHeap` to manage CBV (Constant Buffer View) and SRV (Shader Resource View) descriptors. It provides static helper functions for creating these heaps and views, ensuring efficient resource binding for textures and constant buffers.
    - **Shader Variables:** Creates and updates scene-specific shader variables, primarily the light constant buffer.
- **Input Handling:** Provides methods for processing mouse and keyboard input, which can be used to control scene elements or specific game objects.
- **Animation:** Orchestrates the animation of all managed game objects and shaders within the scene.
- **Rendering:** Sets up the graphics pipeline (root signature, descriptor heaps, camera viewports/scissor rects), updates shader variables, binds light data, and then calls the `Render` methods of all contained objects (SkyBox, Terrain, GameObjects, Shaders).

### Core Components Integrated:
- `CShader`: Manages shaders used for rendering objects within the scene.
- `CPlayer`: The player object, whose position and orientation can influence scene elements (e.g., spot light direction).
- `CGameObject`: Base class for all interactive objects in the scene.
- `CSkyBox`: Renders the background sky.
- `CHeightMapTerrain`: Renders the terrain based on a height map.
- `CTexture`: Used by `CScene`'s static methods to create SRVs for various textures.

### Workflow Summary:
1.  **Initialization (`BuildObjects`):**
    *   Creates the graphics root signature.
    *   Initializes the shared `CDescriptorHeap` for CBV/SRV.
    *   Sets up default lights and materials.
    *   Creates `CSkyBox` and `CHeightMapTerrain`.
    *   Initializes `CShader` objects and their associated game objects.
    *   Creates scene-specific shader variables (e.g., light constant buffer).
2.  **Game Loop (`AnimateObjects`, `Render`):**
    *   **`AnimateObjects`:** Updates animations for all game objects and shaders. Adjusts dynamic lights (e.g., spot light following player).
    *   **`Render`:** Sets the root signature and descriptor heaps. Updates camera and scene shader variables. Binds light constant buffer. Renders `CSkyBox`, `CHeightMapTerrain`, `CGameObject`s, and `CShader`s.
3.  **Termination (`ReleaseObjects`):** Releases all scene-specific DirectX 12 resources and managed objects.

## CPlayer Analysis
The `CPlayer` class, inheriting from `CGameObject`, defines the core behavior and properties of the player character in the game. It handles player movement, rotation, and interaction with the camera system. The `CAirplanePlayer` class extends `CPlayer` to implement specific behaviors for an airplane-type player.

### Key Responsibilities:
- **Movement and Position:** Manages the player's 3D position (`m_xmf3Position`) and orientation vectors (`m_xmf3Right`, `m_xmf3Up`, `m_xmf3Look`). Provides methods (`Move`) for directional and vector-based movement.
- **Rotation:** Handles player rotation around its axes (`Rotate`), with different behaviors based on the current camera mode (First-Person, Third-Person, Spaceship). It also manages pitch, yaw, and roll angles.
- **Physics Simulation:** Incorporates basic physics like velocity (`m_xmf3Velocity`), gravity (`m_xmf3Gravity`), maximum speeds (`m_fMaxVelocityXZ`, `m_fMaxVelocityY`), and friction (`m_fFriction`) to simulate realistic movement.
- **Camera Integration:** Closely coupled with the `CCamera` class. It manages the associated camera (`m_pCamera`), updates its position and orientation based on player movement, and provides functionality to switch between different camera modes (`ChangeCamera`, `OnChangeCamera`).
- **Update Logic (`Update`):** The main update function that applies physics, updates player position, calls player-specific and camera-specific callbacks, and regenerates the camera's view matrix.
- **Rendering (`Render`):** Renders the player's visual representation, typically only in third-person camera mode.
- **Extensibility (Callbacks):** Provides virtual callback functions (`OnPlayerUpdateCallback`, `OnCameraUpdateCallback`) for custom logic to be injected during player and camera updates.

### Core Components Integrated:
- `CGameObject`: Base class providing fundamental object properties and hierarchical transformation.
- `CCamera`: Manages the player's view, with specialized derived classes like `CFirstPersonCamera`, `CThirdPersonCamera`, and `CSpaceShipCamera`.
- `CShader`: Used for rendering the player's model.

### `CAirplanePlayer` Specifics:
- **Model Loading:** Loads a specific 3D model (e.g., "Model/Mi24.bin") to represent the airplane.
- **Animated Parts:** Identifies and animates specific parts of the model, such as main and tail rotors, by rotating their corresponding `CGameObject` frames.
- **Camera Mode Customization:** Overrides `ChangeCamera` to set specific physics parameters (friction, gravity, max velocity) and camera properties (offset, time lag, projection matrix, viewport, scissor rect) and for each camera mode, tailored for an airplane.

### Workflow Summary:
1.  **Initialization (`CAirplanePlayer` Constructor):**
    *   Sets up the initial camera mode and its properties.
    *   Initializes the player's shader and loads its 3D model.
    *   Identifies and prepares animated parts (rotors).
2.  **Game Loop (`Update`, `Animate`):**
    *   **`Update`:** Applies physics (gravity, velocity, friction), updates player position, and synchronizes the camera.
    *   **`Animate` (overridden in `CAirplanePlayer`):** Rotates specific animated parts of the airplane model (e.g., rotors) and then calls the base `CPlayer::Animate` for general player animation.
3.  **Input Handling (`Move`, `Rotate`):** Player movement and rotation are directly controlled by input, affecting its position and orientation vectors.
4.  **Camera Switching (`ChangeCamera`):):** Allows dynamic switching between different camera perspectives, adjusting player physics and camera parameters accordingly.
5.  **Rendering (`Render`):** Draws the player's 3D model to the screen, typically when viewed from a third-person perspective.

## CCamera Analysis
The `CCamera` class and its derived classes (`CSpaceShipCamera`, `CFirstPersonCamera`, `CThirdPersonCamera`) provide a robust system for managing the viewpoint in a 3D application. They handle the creation of view and projection matrices, viewport and scissor rectangle settings, and interaction with the player object.

### Key Responsibilities:
- **Viewpoint Management:** Manages the camera's position (`m_xmf3Position`) and orientation vectors (`m_xmf3Right`, `m_xmf3Up`, `m_xmf3Look`).
- **Matrix Generation:** Generates the view matrix (`m_xmf4x4View`) using `LookAtLH` or by directly constructing it from orientation vectors. Generates the projection matrix (`m_xmf4x4Projection`) using `PerspectiveFovLH`.
- **Viewport and Scissor Rectangles:** Sets up the rendering viewport and scissor rectangle for the graphics pipeline.
- **Shader Variable Management:** Creates and maps a constant buffer (`m_pd3dcbCamera`) to store camera information (`VS_CB_CAMERA_INFO` - view matrix, projection matrix, camera position) and updates it to the GPU for shader access.
- **Camera Modes:** Supports different camera modes (First-Person, Third-Person, Spaceship) through derived classes, each implementing specific rotation and update behaviors.
- **Player Interaction:** Can be linked to a `CPlayer` object (`m_pPlayer`) to track its movement and orientation, allowing for player-centric camera behaviors.
- **Smooth Transitions:** `CThirdPersonCamera` uses `m_fTimeLag` to provide smooth camera transitions when following a player.

### Derived Camera Classes:
- **`CSpaceShipCamera`:** Implements rotation relative to the player's local axes, making the camera rotate with the player as if it were fixed to a spaceship.
- **`CFirstPersonCamera`:** Focuses on rotations that simulate a first-person view, often re-aligning the camera's up vector to the world's up vector when switching from other modes.
- **`CThirdPersonCamera`:** Implements a trailing camera that smoothly follows a target (player) at a specified offset, with logic to ensure the camera always looks at the target.

### Workflow Summary:
1.  **Initialization (`CCamera` Constructor, `CreateShaderVariables`):**
    *   Sets default camera parameters (position, orientation, viewport, projection).
    *   Creates and maps the camera constant buffer for GPU communication.
    *   (Fixed: Ensured `CreateShaderVariables` is called in `CGameFramework::BuildIntroScene` to prevent access violation.)
2.  **Matrix Updates (`GenerateViewMatrix`, `GenerateProjectionMatrix`, `RegenerateViewMatrix`):**
    *   Calculates and updates the view and projection matrices based on camera parameters.
3.  **Shader Communication (`UpdateShaderVariables`):**
    *   Transfers the updated view, projection matrices, and camera position to the GPU via the constant buffer.
    *   Binds the constant buffer to the graphics pipeline.
4.  **Mode-Specific Behavior (`Rotate`, `Update` in derived classes):**
    *   **`CSpaceShipCamera::Rotate`:** Rotates the camera's orientation and position around the player's local axes.
    *   **`CFirstPersonCamera::Rotate`:** Handles rotations for a first-person perspective, often clamping pitch and aligning with world up.
    *   **`CThirdPersonCamera::Update`:** Smoothly interpolates the camera's position to follow the player at an offset, always looking at the target.
5.  **Rendering Setup (`SetViewportsAndScissorRects`):**
    *   Applies the camera's viewport and scissor rectangle settings to the command list before rendering.

## CGameObject, CTexture, CMaterial Analysis
These classes form the foundation for representing and rendering all visual objects within the 3D scene. They provide a hierarchical structure, manage visual properties (textures, materials), and handle transformations and animations.

### `CTexture` Class:
- **Purpose:** Manages DirectX 12 texture resources and their associated shader resource views (SRVs). It handles loading textures from files (DDS), creating buffer resources, and binding them to shaders.
- **Key Features:**
    - **Resource Management:** Stores `ID3D12Resource` pointers for textures and their upload buffers.
    - **SRV Creation:** Configures `D3D12_SHADER_RESOURCE_VIEW_DESC` based on texture type (2D, array, cubemap, buffer).
    - **Shader Binding:** Provides methods to update shader variables by setting graphics root descriptor tables with GPU descriptor handles.
    - **Reference Counting:** Implements `AddRef` and `Release` for memory management.
    - **Duplicated Texture Handling:** Efficiently reuses SRVs for textures that are referenced multiple times within a model hierarchy.
- **CTexture Resource Pointer Nullification:** To further enhance robustness and prevent potential use-after-free or double-free issues with `ID3D12Resource` pointers, the `CTexture::~CTexture()` destructor and `CTexture::ReleaseUploadBuffers()` function were modified. After calling `Release()` on an `ID3D12Resource` pointer, the pointer is now explicitly set to `NULL`. This ensures that once a resource is released, its corresponding pointer no longer holds an invalid address.
- **CTexture Copy/Assignment Prevention:** To address a heap corruption error (`0xC0000374`) occurring during `m_ppstrTextureNames` deallocation in `CTexture::~CTexture()`, the copy constructor and copy assignment operator of the `CTexture` class were explicitly deleted (`= delete`). This prevents unintended shallow copies of `CTexture` objects, which could lead to multiple objects attempting to deallocate the same dynamically allocated memory (`m_ppstrTextureNames`), thus causing double-free and heap corruption.

### `CMaterial` Class:
- **Purpose:** Defines the visual properties of a surface, including colors, texture maps, and the shader used to render it.
- **Key Features:**
    - **Color Properties:** Stores albedo, emissive, specular, and ambient colors.
    - **PBR Properties:** Includes glossiness, smoothness, specular highlight, metallic, and glossy reflection for physically based rendering.
    - **Texture and Shader Association:** Links a `CTexture` object and a `CShader` object to the material.
    - **Shader Variable Update:** Passes material properties (colors, type) to the shader using root constants and updates associated textures.
    - **Reference Counting:** Implements `AddRef` and `Release` for memory management.

### `CGameObject` Class:
- **Purpose:** The base class for all renderable entities in the 3D scene. It supports hierarchical transformations, mesh and material assignment, animation, and rendering.
- **Key Features:**
    - **Hierarchical Structure:** Uses `m_pParent`, `m_pChild`, and `m_pSibling` pointers to form a scene graph, enabling complex object relationships and transformations.
    - **Transformations:** Manages local (`m_xmf4x4Transform`) and world (`m_xmf4x4World`) transformation matrices. Provides methods for setting position, scale, and applying various movements (strafe, up, forward) and rotations (pitch, yaw, roll, axis-angle, quaternion).
    - **Animation:** Provides a virtual `Animate` method that recursively updates transformations for child and sibling objects.
    - **Rendering:** A virtual `Render` method that sets up shader variables (world matrix, material properties) and then renders the associated meshes. It recursively renders child and sibling objects.
    - **Mesh and Material Assignment:** Can hold multiple `CMesh` and `CMaterial` objects.
    - **Shader Variable Management:** Updates the object's world matrix to the shader via root constants.
    - **Model Loading:** Static methods (`LoadFrameHierarchyFromFile`, `LoadGeometryFromFile`) to load complex 3D models (frames, meshes, materials, textures) from custom binary files, reconstructing the hierarchical structure.
    - **Reference Counting:** Implements `AddRef` and `Release` for memory management, extending to child and sibling objects.
- **CGameObject Copy/Assignment Prevention:** To address a heap corruption error (`0xC0000374`) occurring during `CGameObject` destruction, the copy constructor and copy assignment operator of the `CGameObject` class were explicitly deleted (`= delete`). This prevents unintended shallow copies of `CGameObject` objects, which could lead to multiple objects attempting to deallocate the same dynamically allocated memory (e.g., `m_ppMeshes`, `m_ppMaterials`, child/sibling pointers), thus causing double-free and heap corruption.

### Derived `CGameObject` Classes:
- **`CSuperCobraObject`, `CGunshipObject`, `CMi24Object`:** Represent specific helicopter models. They override `Animate` to implement rotor animations by rotating specific child frames (e.g., "MainRotor", "TailRotor").
- **`CSkyBox`:** Renders a skybox. It creates a `CSkyBoxMesh`, loads a cubemap texture, and overrides `Render` to position the skybox at the camera's location.
- **`CHeightMapTerrain`:** Renders terrain based on a height map. It uses `CHeightMapImage` to store height data, divides the terrain into `CHeightMapGridMesh` blocks, and applies terrain-specific textures and shaders.

### Workflow Summary:
1.  **Model Loading:** `CGameObject::LoadGeometryFromFile` reads a binary file, recursively creating a hierarchy of `CGameObject`s, each with its meshes and materials. `CTexture::LoadTextureFromFile` handles texture loading and SRV creation, including optimization for duplicated textures.
2.  **Initialization:** `CGameObject`s are created, meshes and materials are assigned, and initial transformations are set. `CMaterial`s are linked to `CTexture`s and `CShader`s.
3.  **Game Loop (`Animate`, `UpdateTransform`, `Render`):**
    *   **`Animate`:** Called recursively to update object-specific animations (e.g., rotor rotations).
    *   **`UpdateTransform`:** Called recursively to compute the world transformation matrix for each object based on its local transform and parent's world transform.
    *   **`Render`:** Called recursively to render each object. It sets the object's world matrix and material properties in the shader, then draws its meshes.
4.  **Resource Management:** `AddRef`/`Release` manage object lifetimes, and `ReleaseUploadBuffers` frees temporary GPU resources.

## CMesh, CRawFormatImage, CHeightMapImage Analysis
These classes are fundamental for defining the geometric structure of 3D objects and managing their vertex and index data for rendering. They also provide specialized functionality for heightmap-based terrain generation.

### `CMesh` Class:
- **Purpose:** The base class for all mesh types, providing common functionality for managing vertex and index buffers, primitive topology, and rendering.
- **Key Features:**
    - **Buffer Management:** Manages `ID3D12Resource` for position data (`m_pd3dPositionBuffer`) and index data for sub-meshes (`m_ppd3dSubSetIndexBuffers`), along with their corresponding upload buffers and `D3D12_VERTEX_BUFFER_VIEW`/`D3D12_INDEX_BUFFER_VIEW`.
    - **Primitive Topology:** Stores the `D3D12_PRIMITIVE_TOPOLOGY` (e.g., `TRIANGLELIST`, `TRIANGLESTRIP`).
    - **Rendering:** The virtual `Render` method sets the primitive topology, binds vertex buffers, and then draws either indexed or non-indexed instances.
    - **Reference Counting:** Implements `AddRef` and `Release` for memory management.
    - **Upload Buffer Release:** `ReleaseUploadBuffers` frees temporary GPU resources used for data transfer.

### Derived `CMesh` Classes:
- **`CSkyBoxMesh`:** Creates a cube mesh (36 vertices, 6 faces) with inward-pointing normals, suitable for skybox rendering.
- **`CTexturedRectMesh`:** Generates a textured rectangle mesh. It supports creating planes along X, Y, or Z axes and manages texture coordinate buffers.
- **`CStandardMesh`:** A versatile mesh class designed to load complex 3D model data from files. It supports various vertex components (positions, colors, normals, tangents, bitangents, multiple texture coordinates) and manages their respective buffers. It can also handle sub-meshes (material groups) with their own index buffers.
- **`CHeightMapGridMesh`:** Generates a grid mesh based on heightmap data, typically used for terrain. It calculates vertex positions, colors, and texture coordinates from a `CHeightMapImage` and creates an optimized `TRIANGLESTRIP` index buffer.

### `CRawFormatImage` Class:
- **Purpose:** A utility class for loading and managing raw image data from files, primarily used as a base for heightmaps.
- **Key Features:**
    - **Raw Data Loading:** Reads pixel data directly from a file into a `BYTE` array.
    - **Image Dimensions:** Stores width and length of the image.
    - **Y-axis Flipping:** Supports flipping the image data along the Y-axis during loading.

### `CHeightMapImage` Class:
- **Purpose:** Extends `CRawFormatImage` to provide heightmap-specific functionalities, such as calculating height and normal vectors at given coordinates.
- **Key Features:**
    - **Height Calculation:** Interpolates height values from the raw heightmap data at any given (x, z) world coordinate.
    - **Normal Calculation:** Computes the normal vector at a specific (x, z) point on the heightmap, useful for lighting calculations.
    - **Scaling:** Applies a scale factor (`m_xmf3Scale`) to the height values.

### Workflow Summary:
1.  **Mesh Creation:**
    *   **`CStandardMesh`:** `LoadMeshFromFile` reads vertex and index data from a custom file format, allocating CPU memory for vertex components and then creating corresponding `ID3D12Resource` (vertex/index buffers) on the GPU.
    *   **`CSkyBoxMesh`, `CTexturedRectMesh`:** Their constructors directly generate vertex data and create GPU buffers.
    *   **`CHeightMapGridMesh`:** Its constructor takes a `CHeightMapImage` as context, calculates vertex positions (using `OnGetHeight`), colors (using `OnGetColor`), and texture coordinates, then creates GPU buffers for these components and an `index buffer` for `TRIANGLESTRIP` rendering.
2.  **Data Transfer:** `CreateBufferResource` (a helper function, likely defined elsewhere) is used to transfer vertex/index data from CPU memory to GPU default heaps, often using intermediate upload heaps.
3.  **Rendering:** The `Render` method of each mesh type binds its specific vertex and/or index buffers to the graphics pipeline and issues a draw call.
4.  **Resource Cleanup:** Destructors release GPU resources, and `ReleaseUploadBuffers` frees temporary GPU resources.

## CShader Analysis
The `CShader` class and its derived classes (`CSkyBoxShader`, `CStandardShader`, `CObjectsShader`, `CPlayerShader`, `CTerrainShader`) are central to the rendering pipeline, managing shader programs and Pipeline State Objects (PSOs). They encapsulate the logic for compiling shaders, configuring rendering states, and binding resources to the GPU.

### `CShader` Class:
- **Purpose:** The base class for all shader types, providing common functionality for shader compilation, PSO creation, and rendering.
- **Key Features:**
    - **Shader Compilation:** Provides `CompileShaderFromFile` to compile HLSL shader files and `ReadCompiledShaderFromFile` to load pre-compiled shader binaries (CSO).
    - **PSO Management:** Manages `ID3DBlob` for compiled shader bytecode and `ID3D12PipelineState` objects.
    - **Configurable PSO States:** Virtual methods (`CreateInputLayout`, `CreateRasterizerState`, `CreateBlendState`, `CreateDepthStencilState`) allow derived classes to customize specific rendering states for their PSOs.
    - **Shader Variable Management:** Virtual methods for creating, updating, and releasing shader-specific variables (e.g., constant buffers).
    - **Rendering Flow:** Provides `OnPrepareRender` to set the PSO and `Render` as the entry point for drawing.
    - **Reference Counting:** Implements `AddRef` and `Release` for memory management.

### Derived `CShader` Classes:
- **`CSkyBoxShader`:** Specialized for rendering skyboxes. It defines an input layout for positions only, and a depth/stencil state that disables depth testing and writing to ensure the skybox is always rendered in the background. It compiles "VSSkyBox" and "PSSkyBox" from "Shaders.hlsl".
- **`CStandardShader`:** A general-purpose shader for standard 3D objects. It defines an input layout for positions, texture coordinates, normals, tangents, and bitangents. It compiles "VSStandard" and "PSStandard" from "Shaders.hlsl".
- **CObjectsShader:** Extends `CStandardShader` to manage and render a collection of `CGameObject`s (e.g., multiple instances of helicopters). It includes logic to build these objects (loading models, setting random positions), animate them, and render them in a loop. (Fixed `m_ppObjects` initialization to `nullptr` for C++11 compliance.)
- **`CPlayerShader`:** Designed for rendering the player character. It uses the same input layout and shaders ("VSStandard", "PSStandard") as `CStandardShader`, suggesting a similar rendering approach for the player model.
- **`CTerrainShader`:** Tailored for rendering terrain. It defines an input layout for positions, colors, and two sets of texture coordinates. It compiles "VSTerrain" and "PSTerrain" from "Shaders.hlsl".

### Workflow Summary:
1.  **Shader Creation (`CreateShader`):**
    *   Derived classes override `CreateVertexShader`, `CreatePixelShader`, `CreateInputLayout`, and other state creation methods to define their specific rendering pipeline.
    *   The base `CShader::CreateShader` method then uses these definitions to construct a `D3D12_GRAPHICS_PIPELINE_STATE_DESC` and create an `ID3D12PipelineState` object.
2.  **Rendering (`Render`):**
    *   The `Render` method (or `OnPrepareRender`) sets the appropriate `ID3D12PipelineState` on the command list.
    *   Shader variables (e.g., world matrix, material properties, camera info, light info) are updated and bound to the GPU.
    *   The actual drawing of meshes is typically handled by the `CMesh::Render` method, which is called by the `CGameObject::Render` method.
3.  **Object Management (e.g., `CObjectsShader`):**
    *   `CObjectsShader::BuildObjects` loads 3D models and creates multiple `CGameObject` instances, setting their initial positions and animations.
    *   `CObjectsShader::Render` iterates through its managed objects, updates their transformations and animations, and then calls their individual `Render` methods.
## Intro Scene Implementation
- **Objective:** Implemented a separate scene for the intro/start screen to improve modularity, performance, and flexibility.
- **CIntroScene Class:** A new class derived from `CScene` was created to manage the intro screen.
- **CTexturedRectObject:** A new `CGameObject` derived class, `CTexturedRectObject`, was implemented to render a full-screen textured rectangle, used for displaying the intro background image.
- **GameFramework Integration:**
    - Modified `CGameFramework::OnCreate` to initially load `CIntroScene`.
    - Renamed `CGameFramework::BuildObjects` to `CGameFramework::BuildGameScene` to clearly separate game scene initialization.
    - Added `CGameFramework::BuildIntroScene` for intro scene specific initialization.
    - Implemented scene transition logic in `CGameFramework::OnProcessingMouseMessage` and `CGameFramework::OnProcessingKeyboardMessage`. When a specific input (e.g., mouse click, Enter key) is detected in `CIntroScene`, the current scene is released, `m_bGameStarted` is set to true, and `BuildGameScene` is called to load the main game.
    - Updated `CGameFramework::ReleaseObjects` to correctly release `m_pPlayer` and `m_pCamera`.
    - Modified `CGameFramework::AnimateObjects` and `CGameFramework::FrameAdvance` to conditionally animate and render the player and display player-specific information only after `m_bGameStarted` is true.
- **Workflow:** The application now starts with `CIntroScene`. Upon user interaction, it transitions to `CGameScene`, loading all game-related assets and enabling player controls.
## Intro Scene Implementation (Continued)
- **Button Implementation:** Added "Play" and "Exit" buttons to `CIntroScene` using `CTexturedRectObject`.
    - Loaded `Play_Default.dds`, `Play_Hover.dds`, `Home_Default.dds`, `Home_Hover.dds` textures for button states.
    - Configured `CScene::CreateShaderResourceView` to assign unique root parameter indices (4-7) for these button textures.
    - Positioned buttons centrally on the screen, with "Exit" below "Play".
- **Mouse Interaction:** Implemented mouse hover and click detection in `CIntroScene::OnProcessingMouseMessage`.
    - Mouse hover over a button changes its texture to the `_Hover` version.
    - Left-click on the "Play" button triggers a scene transition to the main game.
    - Left-click on the "Exit" button terminates the application.
- **CGameObject Enhancement:** Added `CMaterial* GetMaterial(int nIndex)` method to `CGameObject` to allow direct access to an object's material for dynamic texture changes.
- **CTexture Double Free Fix:** Corrected an access violation error occurring in the `CTexture` destructor. The fix involved removing redundant `Release()` calls for `CTexture` objects (`m_pPlayButtonDefaultTexture`, `m_pPlayButtonHoverTexture`, `m_pExitButtonDefaultTexture`, `m_pExitButtonHoverTexture`) within `CIntroScene::ReleaseObjects`. These `CTexture` objects are managed by `CMaterial` through reference counting, and `CMaterial`'s destructor correctly handles their release, preventing double-free issues.
- **Intro Scene Button Object Visibility Fix:** Resolved the issue where button objects were not visible in the intro scene.
    - Removed an unnecessary `CreateShaderVariables()` call from `CIntroScene::BuildObjects()`, as the intro scene does not require scene-level light constant buffers.
    - Introduced a new shader class, `CIntroUIShader`, inheriting from `CStandardShader`. This new shader overrides `CreateDepthStencilState()` to disable depth testing and depth writing, ensuring UI elements are always rendered on top without being obscured by other objects.
    - Modified `CIntroScene::BuildObjects()` to use `CIntroUIShader` for the background image and all button objects instead of `CStandardShader`.
- **Intro Scene Button Object Visibility Fix (Material Type):** Further resolved the issue where button objects were not visible in the intro scene. The `CMaterial` for the background image, play button, and exit button were updated in `CIntroScene::BuildObjects()` to explicitly set the `MATERIAL_ALBEDO_MAP` flag using `SetMaterialType(MATERIAL_ALBEDO_MAP)`. This ensures that the `PSStandard` shader correctly samples the albedo texture, allowing the UI elements to be rendered with their intended textures.
- **Intro Scene Button Object Visibility Fix (Root Parameter Index Unification):** Finalized the fix for invisible UI buttons. All `CScene::CreateShaderResourceView` calls within `CIntroScene::BuildObjects()` for the background image, play button (default/hover), and exit button (default/hover) now use a unified `nRootParameterStartIndex` of `3`. This ensures all UI textures are bound to Root Parameter 3, which maps to the `gtxtAlbedoTexture` (t6) register in the `PSStandard` shader. Combined with the `MATERIAL_ALBEDO_MAP` flag set on their respective `CMaterial`s, this resolves the texture binding and shader sampling mismatch, allowing UI elements to render correctly.
- **nullptr Access Violation Fix in CIntroScene::BuildObjects():** Resolved a critical `nullptr` read access violation occurring in `CIntroScene::BuildObjects()` when attempting to call `LoadTextureFromDDSFile` on uninitialized `CTexture*` member variables (e.g., `m_pPlayButtonDefaultTexture`). The fix involved adding explicit `new CTexture(...)` allocations for `m_pPlayButtonDefaultTexture`, `m_pPlayButtonHoverTexture`, `m_pExitButtonDefaultTexture`, and `m_pExitButtonHoverTexture` immediately before their respective `LoadTextureFromDDSFile` calls. This ensures that these texture pointers correctly point to valid `CTexture` objects, preventing the `nullptr` dereference.
- **Intro Scene to Game Scene Transition Re-enabled:** Modified `CGameFramework::OnCreate()` to revert the initial scene loading from `BuildGameScene()` back to `BuildIntroScene()`. The `m_bGameStarted = true;` line was also removed from `OnCreate()`. This change re-establishes the intro scene as the application's starting point. The existing logic in `CGameFramework::OnProcessingKeyboardMessage()` and `CIntroScene::OnProcessingKeyboardMessage()` (which returns `true` on `VK_RETURN` key press) will now correctly trigger the transition from the intro scene to the game scene.
- **UI Object Visibility Test (Diffuse Color & Z-position):** To diagnose why UI objects were not rendering, `CIntroScene::BuildObjects()` was modified:
    - Explicit diffuse colors were set for the materials of the background image (red), play button (green), and exit button (blue). This ensures that if the objects are rendered, they will appear as solid colors, bypassing any texture-related issues.
    - The Z-position of the play and exit buttons was adjusted from `-5.0f` to `-0.1f` to prevent potential camera clipping issues and ensure they are rendered in front of the background.